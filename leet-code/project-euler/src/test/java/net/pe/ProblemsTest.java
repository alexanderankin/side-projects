package net.pe;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.CsvSource;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.function.Predicate;
import java.util.stream.IntStream;
import java.util.stream.Stream;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertTrue;

@SuppressWarnings("SameParameterValue")
class ProblemsTest {
    private static boolean[] PROBLEM_SEVEN;

    /**
     * If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3,5,6 and 9. The sum of these multiples is 23.
     * <p>
     * Find the sum of all the multiples of 3 or 5 below 1000.
     */
    int problemOne_naive(int upTo) {
        int result = 0;
        for (int i = 0; i < upTo; i++) {
            if (i % 5 == 0 || i % 3 == 0)
                result += i;
        }
        return result;
    }

    /**
     * @see #problemOne_naive(int)
     */
    int problemOne(int upTo) {
        var nums5 = (upTo - 1) / 5;
        var nums3 = (upTo - 1) / 3;
        var nums15 = (upTo - 1) / 15;

        var sum3 = (nums3 * (nums3 + 1) / 2) * 3;
        var sum5 = (nums5 * (nums5 + 1) / 2) * 5;
        var sum15 = (nums15 * (nums15 + 1) / 2) * 15;
        return sum3 + sum5 - sum15;
    }

    @ParameterizedTest
    @CsvSource({
            "10,23",
            "0,0",
            "3,0",
            "4,3",
            "6,8",
            "20,78",
            "1000,233168",
    })
    void test_problemOne(int upTo, int expected) {
        assertEquals(expected, problemOne_naive(upTo));
        assertEquals(expected, problemOne(upTo));
    }

    List<Integer> problemOneIntermediate_naive(int upTo) {
        List<Integer> result = new ArrayList<>();
        for (int i = 1; i < upTo; i++) {
            if (i % 5 == 0 || i % 3 == 0)
                result.add(i);
        }
        return result;
    }

    List<Integer> problemOneIntermediate(int upTo) {
        var nums5 = (upTo - 1) / 5;
        var nums3 = (upTo - 1) / 3;

        var result3 = IntStream.rangeClosed(1, nums3).map(i -> i * 3).boxed().toList();
        var result5 = IntStream.rangeClosed(1, nums5).map(i -> i * 5).boxed().toList();
        return Stream.concat(result3.stream(), result5.stream()).distinct().sorted().toList();
    }

    @ParameterizedTest
    @CsvSource({
            "0,''",
            "3,''",
            "4,'3'",
            "6,'3,5'",
            "10,'3,5,6,9'",
            "20,'3,5,6,9,10,12,15,18'",
    })
    void test_p1_intermediate(int upTo, String expectedString) {
        List<Integer> expected = Arrays.stream(expectedString.split(",")).filter(Predicate.not(String::isEmpty)).map(Integer::parseInt).toList();

        assertEquals(expected, problemOneIntermediate_naive(upTo), "naive");
        assertEquals(expected, problemOneIntermediate(upTo), "efficient");
    }

    /**
     * Each new term in the Fibonacci sequence is generated by adding the previous two terms.
     * By starting with 1 and 2, the first 10 terms will be:1,2,3,5,8,13,21,34,55,89,...
     * <p>
     * By considering the terms in the Fibonacci sequence whose values do not exceed four million,
     * find the sum of the even-valued terms.
     */
    long problemTwo(int upTo) {
        long result = 0;
        int fib0 = 0;
        int fib1 = 1;
        while (true) {
            int fib = fib0 + fib1;
            if (fib > upTo) break;
            if (fib % 2 == 0)
                result += fib;
            fib0 = fib1;
            fib1 = fib;
        }
        return result;
    }

    @ParameterizedTest
    @CsvSource({
            // "10,44",  // misinterpreted upTo as count initially
            "4000000,4613732",
    })
    void test_problemTwo(int upTo, long expected) {
        assertEquals(expected, problemTwo(upTo));
    }

    long problemTwo(long input) {
        return primeFactors(input).stream().mapToLong(Long::longValue).reduce(0, Math::max);
    }

    @ParameterizedTest
    @CsvSource({
            "13195,29",
            "600851475143,6857",
    })
    void test_problemThree(long input, long expected) {
        assertEquals(expected, problemTwo(input));
    }

    // https://www.geeksforgeeks.org/java-program-for-efficiently-print-all-prime-factors-of-a-given-number/
    public List<Long> primeFactors(long n) {
        List<Long> primes = new ArrayList<>();
        // Print the number of 2s that divide n
        while (n % 2 == 0) {
            // System.out.print(2 + " ");
            primes.add((long) 2);
            n /= 2;
        }

        // n must be odd at this point.  So we can
        // skip one element (Note i = i +2)
        for (int i = 3; i <= Math.sqrt(n); i += 2) {
            // While i divides n, print i and divide n
            while (n % i == 0) {
                // System.out.print(i + " ");
                primes.add((long) i);
                n /= i;
            }
        }

        // This condition is to handle the case when
        // n is a prime number greater than 2
        if (n > 2)
            primes.add(n);
        return primes;
    }

    /**
     * A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit
     * numbers is 9009=91×99.Find the largest palindrome made from the product of two 3-digit numbers.
     */
    long problemFour(int nDigits) {
        // equation: x1 * 10^4 + x2 * 10^3 + x2 * 10^2 + x1 * 10^1
        // sum x{1..n} = xi * 10^i + xi * 10^(n - i)
        // sum x{1..n} = xi(10^i + 10^(n - i))
        // sum = y * z
        // ok, naive solution:
        long start = (long) Math.pow(10, nDigits - 1);
        long end = 0;
        for (int i = 0; i < nDigits; i++) {
            end *= 10;
            end += 9;
        }

        long max = 0;

        long a = end;
        while (a >= start) {
            long b = end;
            while (b >= a) {
                long product = a * b;
                if (isPalindrome(product) && product > max)
                    max = product;
                b--;
            }
            a--;
        }
        return max;

        // we can apparently also optimize by using the 11 multiple fact

        // back to the good stuff, the incomprehensible euler stuff:
        // xy
        // P=1000x+100y+10y+x
        // P=1001x+110y
        // P=(91x+10y)11
        // xyz
        // P=100000x10000y1000z100z10yx
        // P=100001x10010y1100z
        // P=119091x910y100z
        // wxyz
        // P=10000000w+1000000x+100000y+10000z+1000z+100y+10x+w
        // P=10000001w+1000010x+100100y+11000z
        // P=(909091w+90910x+9100y+1000z)11
    }

    boolean isPalindrome(long num) {
        long reverse = 0;
        long copy = num;
        while (copy > 0) {
            reverse *= 10;
            reverse += copy % 10;
            copy /= 10;
        }
        return num == reverse;
    }

    @ParameterizedTest
    @CsvSource({
            "1,9",
            "2,9009",
            "3,906609",
            // "4,99000099",
            // "5,9966006699",
    })
    void test_problemFour(int size, long expected) {
        assertEquals(expected, problemFour(size));
    }

    @ParameterizedTest
    @CsvSource({
            "true,4",
            "true,44",
            "false,445",
            "true,5445",
            "false,1234",
    })
    void test_isPalindrome(boolean expected, int input) {
        assertEquals(expected, isPalindrome(input));
    }

    /**
     * smallest multiple
     */
    int problem5(int upTo) {
        int next = upTo * upTo;
        // try to reduce the amount of tests on each multiple of largest number (upTo)
        // boolean[] yes = new boolean[upTo];
        // Arrays.fill(yes, true);
        //
        // List<Integer> numsToTry = new ArrayList<>();
        // for (int i = upTo - 1; i > 0; i--) {
        //     if (!yes[i]) continue;
        //     for (int j = 2; j < i; j++) {
        //         if (i % j == 0) {
        //             yes[j] = false;
        //         }
        //     }
        // }
        //
        // for (int i = 2; i < upTo; i++) {
        //     if (yes[i])
        //         numsToTry.add(i);
        // }
        //
        // but as it turns out, it is just the larger half
        // System.out.println(numsToTry);
        var numsToTry = IntStream.rangeClosed(upTo / 2, upTo).toArray();

        int limit = Integer.MAX_VALUE;
        while (limit-- > 0) {
            boolean even = true;
            for (int i : numsToTry) {
                if (next % i != 0) {
                    even = false;
                    break;
                }
            }

            if (even) return next;
            next += upTo;
        }
        return -1;
    }

    @ParameterizedTest
    @CsvSource({
            "10,2520",
            "20,232792560",
    })
    void test_problem5(int upTo, int expected) {
        assertEquals(expected, problem5(upTo));
    }

    int problemSix(int upTo) {
        var squareOfSum = Math.pow(IntStream.rangeClosed(1, upTo).sum(), 2);
        var sumOfSquare = IntStream.rangeClosed(1, upTo).map(i -> i * i).sum();

        return (int) (squareOfSum - sumOfSquare);
    }

    @ParameterizedTest
    @CsvSource({
            "10,2640",
            "100,25164150",
    })
    void test_problemSix(int upTo, int expected) {
        assertEquals(expected, problemSix(upTo));
    }

    /**
     * @param n how many nums to generate
     * @return nth prime
     */
    int problemSeven(int n) {
        if (PROBLEM_SEVEN == null)
            PROBLEM_SEVEN = sieveOfEratosthenes(nPrimesErHelper_piN(10_000));
        for (int i = 2; i < PROBLEM_SEVEN.length; i++) {
            if (PROBLEM_SEVEN[i]) n--;
            if (n == 0) return i;
        }
        throw new IllegalStateException("not found");
    }

    @ParameterizedTest
    @CsvSource({
            "1,2",
            "2,3",
            "3,5",
            "4,7",
            "5,11",
            "6,13",
            "10001,104743",
    })
    void test_problemSeven(int n, int nthPrime) {
        assertEquals(nthPrime, problemSeven(n));
    }

    //<editor-fold desc="Primes: Simple G4G approach">
    List<Integer> nPrimes(int n) {
        List<Integer> result = new ArrayList<>();
        outer:
        // start at 2
        for (int i = 2; ; i++) {
            // each go from i to i/2, checking if any divide
            for (int j = 2; j <= i / 2; ++j) {
                if (i % j == 0) {
                    continue outer;
                }
            }
            result.add(i);
            if (result.size() == n)
                break;
        }

        return result;
    }

    int nthPrime(int n) {
        int counter = 0;
        outer:
        // start at 2
        for (int i = 2; ; i++) {
            // each go from i to i/2, checking if any divide
            for (int j = 2; j <= i / 2; ++j) {
                if (i % j == 0) {
                    continue outer;
                }
            }
            counter++;
            if (counter == n)
                return i;
        }
    }

    @Test
    void test_nPrimes() {
        assertEquals(List.of(2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43), nPrimes(14));
        assertEquals(43, nthPrime(14));
    }

    // https://www.geeksforgeeks.org/java-program-to-display-all-prime-numbers-from-1-to-n/
    @SuppressWarnings("unused")
    void prime_N(int N) {
        // Declaring the variables
        int x, y, flg;

        // Using for loop for traversing all
        // the numbers from 1 to N
        for (x = 1; x <= N; x++) {

            // Omit 0 and 1 as they are
            // neither prime nor composite
            if (x == 1 || x == 0)
                continue;

            // Using flag variable to check
            // if x is prime or not
            flg = 1;

            for (y = 2; y <= x / 2; ++y) {
                if (x % y == 0) {
                    flg = 0;
                    break;
                }
            }

            // If flag is 1 then x is prime but
            // if flag is 0 then x is not prime
            if (flg == 1)
                System.out.println(x);
        }
    }
    //</editor-fold>

    //<editor-fold desc="Primes: Eratosthenes G4G approach">
    int nPrimesErHelper_piN(int n) {
        // https://en.wikipedia.org/wiki/Prime_number_theorem#Approximations_for_the_nth_prime_number
        // https://math.stackexchange.com/questions/4535527/heuristic-argument-on-the-position-of-nth-prime
        return (int) (1.5 * n * Math.log(n));
    }

    @ParameterizedTest
    @CsvSource({
            "1,2", // 4 = pi(n), or how many primes before 10,
            "2,541", // 25 = pi(100),
            "3,7919", // 168 = pi(1000),
            "4,104729", // 1229,
            "5,1299709", // 9592,
            "6,15485863", // 78498,
            "7,179424673", // 664579,
    })
    void test_nPrimesErHelper_piN(int power, int nthPrime) {
        int n = (int) Math.pow(10, power);
        assertTrue(nthPrime < nPrimesErHelper_piN(n),
                "oh no - our helper was not greater than the actual number of the nth prime");
    }

    List<Integer> nPrimesEr(int n) {
        int size = nPrimesErHelper_piN(n);
        List<Integer> integers = new ArrayList<>();
        var s = sieveOfEratosthenes(size);
        for (int i = 2; i < s.length; i++) if (s[i]) integers.add(i);
        return integers.subList(0, n);
    }

    @Test
    void test_nPrimesEr() {
        assertEquals(List.of(2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43), nPrimesEr(14));
        assertEquals(43, nthPrimeEr(14));
    }

    int nthPrimeEr(int n) {
        int size = nPrimesErHelper_piN(n);
        List<Integer> integers = new ArrayList<>();
        var s = sieveOfEratosthenes(size);
        for (int i = 2; i < s.length; i++) if (s[i]) integers.add(i);
        return integers.get(n - 1);
    }

    boolean[] sieveOfEratosthenes(int n) {
        boolean[] prime = new boolean[n + 1];
        Arrays.fill(prime, true);

        // i from 2 to sqrt n
        for (int i = 2; i * i <= n; i++) {
            // if i is prime
            if (prime[i]) {
                // j from i squared to all multiples of i - not prime
                for (int j = i * i; j <= n; j += i) {
                    prime[j] = false;
                }
            }
        }

        // Print all prime numbers
        // for (int i = 2; i <= n; i++) if (prime[i]) System.out.print(i + " ");
        return prime;
    }
    //</editor-fold>

    long problem8(int length) {
        String input = """
                73167176531330624919225119674426574742355349194934
                96983520312774506326239578318016984801869478851843
                85861560789112949495459501737958331952853208805511
                12540698747158523863050715693290963295227443043557
                66896648950445244523161731856403098711121722383113
                62229893423380308135336276614282806444486645238749
                30358907296290491560440772390713810515859307960866
                70172427121883998797908792274921901699720888093776
                65727333001053367881220235421809751254540594752243
                52584907711670556013604839586446706324415722155397
                53697817977846174064955149290862569321978468622482
                83972241375657056057490261407972968652414535100474
                82166370484403199890008895243450658541227588666881
                16427171479924442928230863465674813919123162824586
                17866458359124566529476545682848912883142607690042
                24219022671055626321111109370544217506941658960408
                07198403850962455444362981230987879927244284909188
                84580156166097919133875499200524063689912560717606
                05886116467109405077541002256983155200055935729725
                71636269561882670428252483600823257530420752963450""";

        long greatestProduct = 1;

        var chars = input.replaceAll("\\s", "").toCharArray();
        for (int i = 0; i < chars.length - (length - 1); i++) {
            long product = 1;
            for (int j = 0; j < length; j++) {
                product *= (chars[i + j] - '0');
            }

            if (product > greatestProduct)
                greatestProduct = product;
        }

        return greatestProduct;
    }

    @ParameterizedTest
    @CsvSource({
            "4,5832",
            "5,40824",
            "6,285768",
            "13,23514624000",
    })
    void test_problem8(int length, long expect) {
        assertEquals(expect, problem8(length));
    }

    int problem9() {
        for (int i = 0; i < 1000; i++) {
            for (int j = 0; j < 1000; j++) {
                if (j == i) continue;
                for (int k = 0; k < 1000; k++) {
                    if (k == i || k == j) continue;

                    if (i * i + j * j != k * k) continue;

                    if (i + j + k == 1000) {
                        System.out.println(i); // 200
                        System.out.println(j); // 375
                        System.out.println(k); // 425

                        return i * j * k;
                    }
                }
            }
        }
        throw new IllegalStateException("not found");
    }

    @Test
    void test_problem9() {
        assertEquals(31875000, problem9());
    }

    long problem10_naive(int n) {
        long result = 0;
        outer:
        // start at 2
        for (int i = 2; i <= n; i++) {
            // each go from i to i/2, checking if any divide
            for (int j = 2; j <= i / 2; ++j) {
                if (i % j == 0) {
                    continue outer;
                }
            }
            result += i;
        }

        return result;
    }

    // sum of primes below n
    long problem10(int n) {
        boolean[] prime = new boolean[n + 1];
        Arrays.fill(prime, true);

        // i from 2 to sqrt n
        for (int i = 2; i * i <= n; i++) {
            // if i is prime
            if (prime[i]) {
                // j from i squared to all multiples of i - not prime
                for (int j = i * i; j <= n; j += i) {
                    prime[j] = false;
                }
            }
        }

        long result = 0;
        for (int i = 2; i < prime.length; i++) {
            if (prime[i]) {
                result += i;
            }
        }
        return result;
    }

    @ParameterizedTest
    @CsvSource({
            "10,17",
            "43,281",
            "2000000,142913828922",
    })
    void test_problem10(int n, long expected) {
        assertEquals(expected, problem10(n));
        if (n < 100)
            assertEquals(expected, problem10_naive(n));
    }
}
